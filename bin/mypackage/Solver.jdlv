package mypackage;

import mypackage.Board.Tile;
import java.util.List;
import java.util.ArrayList;
import java.io.*;

public class Solver
{
	private int MAX_INT=131072;
	private int MAX_SCORE=59577;
	
	public List<Fact> facts=new ArrayList<Fact>();
	public List<String> result=new ArrayList<String>();
	public String strategy;
	Move move;

	Solver(){}
	
	Solver(Move m){
		facts.clear();
		result.clear();
		strategy="null";
		this.move=m;
		if(!java.util.Arrays.deepEquals(m.getGridUP(),m.getGrid()))
		{
			System.out.println("gridUP e Sorgente NON sono uguali");
			facts.add(generateFactS(m.getGridUP(),m.getScoreUP(),"UP"));
		}
		if(!java.util.Arrays.deepEquals(m.getGridDOWN(),m.getGrid()))
		{
			System.out.println("gridDOWN e Sorgente NON sono uguali");
			facts.add(generateFactS(m.getGridDOWN(),m.getScoreDOWN(),"DOWN"));
		}
		if(!java.util.Arrays.deepEquals(m.getGridLEFT(),m.getGrid()))
		{
			System.out.println("gridLEFT e Sorgente NON sono uguali");
			facts.add(generateFactS(m.getGridLEFT(),m.getScoreLEFT(),"LEFT"));
		}
		if(!java.util.Arrays.deepEquals(m.getGridRIGHT(),m.getGrid()))
		{
			System.out.println("gridRIGHT e Sorgente NON sono uguali");
			facts.add(generateFactS(m.getGridRIGHT(),m.getScoreRIGHT(),"RIGHT"));
		}
		
		result.add(DLV());
	}
	
	
	Solver(Move m, String s){
		facts.clear();
		result.clear();
		this.move=m;
		if(!java.util.Arrays.deepEquals(m.getGridUP(),m.getGrid()))
		{
			System.out.println("gridUP e Sorgente NON sono uguali");
			facts.add(generateFactS(m.getGridUP(),m.getScoreUP(),"UP"));
		}
		if(!java.util.Arrays.deepEquals(m.getGridDOWN(),m.getGrid()))
		{
			System.out.println("gridDOWN e Sorgente NON sono uguali");
			facts.add(generateFactS(m.getGridDOWN(),m.getScoreDOWN(),"DOWN"));
		}
		if(!java.util.Arrays.deepEquals(m.getGridLEFT(),m.getGrid()))
		{
			System.out.println("gridLEFT e Sorgente NON sono uguali");
			facts.add(generateFactS(m.getGridLEFT(),m.getScoreLEFT(),"LEFT"));
		}
		if(!java.util.Arrays.deepEquals(m.getGridRIGHT(),m.getGrid()))
		{
			System.out.println("gridRIGHT e Sorgente NON sono uguali");
			facts.add(generateFactS(m.getGridRIGHT(),m.getScoreRIGHT(),"RIGHT"));
		}
		
		this.strategy=s;
		
		result.add(DLV());
	}
	
	public String DLV()
	{
		List<String> res= new ArrayList<String>();
		
		for(Fact f : facts)
			System.out.println(f+".");
		System.out.println("CommonChoice("+'"'+strategy+'"'+").");
		
		if(move.getPrevious()!=null)
			System.out.println("PreviousChoice("+'"'+move.getPrevious().name()+'"'+").");
		
		writeFactsFile(facts,move);
		
		
		<#(newProgram)
			EXE="./dlv.mingw-odbc.exe";
		//	IN = facts::Grid;
			FILE = "./facts.txt";
			OUT = res::Best;
			
			
			//Grid(1,1,1,1,1,1,1,1,1,1,1,0,"test1",0).
			//Grid(0,1,1,1,1,1,1,1,1,1,1,0,"test2",0).
			//Grid(0,0,1,1,1,1,1,1,1,1,1,0,"test3",0).
			//Grid(0,0,0,1,1,1,1,1,1,1,1,0,"test4",0).
			//Grid(0,0,0,0,1,1,1,1,1,1,1,0,"test5",0).
			//Grid(0,0,0,0,0,1,1,1,1,1,1,0,"test6",0).
			//Grid(0,0,0,0,0,0,1,1,1,1,1,0,"test7",0).
			//Grid(0,0,0,0,0,0,0,1,1,1,1,0,"test8",0).
			//Grid(0,0,0,0,0,0,0,0,1,1,1,0,"test9",0).
			//Grid(0,0,0,0,0,0,0,0,0,1,1,0,"test10",0).
			//Grid(0,0,0,0,0,0,0,0,0,0,1,0,"test11",0).

			
			//Guess
			Best(M) | notBest(M) :- Grid(_,_,_,_,_,_,_,_,_,_,_,_,M,_).
			
		//NotEmptyCell(NEC,M) :- NEC = #sum {A,B,C,D,E,F,G,H,I,L : Grid(_,A,B,C,D,E,F,G,H,I,L,_,M,_)}.
			
			//Check
			:-#count{M:Best(M)} = 0. //Esiste sempre una mossa Best
			:-#count {M:Best(M)} > 1. //Esiste una sola mossa Best
			:-Best(M),Grid(A,B,C,D,E,F,G,H,I,L,N,O,M,V),Grid(A,B,C,D,E,F,G,H,I,L,N,O,M1,V1),V<V1. //Se esistono due mosse dallo stesso esito si sceglie quella con score pi\ alto
		
			//WEAK che non permettono di generare una mossa opposta alla precedente per non incasinare la griglia
			:~Best("DOWN"),PreviousChoice("UP").[1:20]
			:~Best("UP"),PreviousChoice("DOWN").[1:20]
			:~Best("LEFT"),PreviousChoice("RIGHT").[1:20]
			:~Best("RIGHT"),PreviousChoice("LEFT").[1:20]
		
			//WEAK di Minimizzazione
			:~Best(M),not CommonChoice(M). [1:1]
			
			:~Best(M),Grid(_,TWO,_,_,_,_,_,_,_,_,_,_,M,_). [TWO:12] //Minimizza celle TWO
			
			:~Best(M),Grid(_,_,FOUR,_,_,_,_,_,_,_,_,_,M,_). [FOUR:12] //Minimizza celle FOUR
			
			:~Best(M),Grid(_,_,_,EIGHT,_,_,_,_,_,_,_,_,M,_). [EIGHT:11]//Minimizza celle EIGHT
			
			:~Best(M),Grid(_,_,_,_,SIXTEEN,_,_,_,_,_,_,_,M,_). [SIXTEEN:9]//Minimizza celle SIXTEEN
			
			:~Best(M),Grid(_,_,_,_,_,THIRTYTWO,_,_,_,_,_,_,M,_). [THIRTYTWO:8] //Minimizza celle THIRTYTWO
			
			:~Best(M),Grid(_,_,_,_,_,_,SIXTYFOUR,_,_,_,_,_,M,_). [SIXTYFOUR:7] //Minimizza celle SIXTYFOUR
			
			:~Best(M),Grid(_,_,_,_,_,_,_,ONEHUNDERDTWENTYEIGHT,_,_,_,_,M,_). [ONEHUNDERDTWENTYEIGHT:6] //Minimizza celle ONEHUNDREDTWENTYEIGHT
			
			:~Best(M),Grid(_,_,_,_,_,_,_,_,TWOHUNDREDFIFTYSIX,_,_,_,M,_). [TWOHUNDREDFIFTYSIX:5] //Minimizza celle TWOHUNDREDFIFTYSIX
			
			:~Best(M),Grid(_,_,_,_,_,_,_,_,_,FIVEHUNDREDTWELVE,_,_,M,_). [FIVEHUNDREDTWELVE:4] //Minimizza celle FIVEHUNDREDTWELVE
			
			:~Best(M),Grid(_,_,_,_,_,_,_,_,_,_,ONETHOUSANDTWENTYFOUR,_,M,_). [ONETHOUSANDTWENTYFOUR:3] //Minimizza celle ONETHOUSANDTWENTYFOUR
			
			:~Best(M),Grid(E,_,_,_,_,_,_,_,_,_,_,_,M,_). [E:2] //Minimizza celle EMPTY
			
		//	:~Best(M),Grid(_,_,_,_,_,_,_,_,_,_,_,TWOTHOUSANDFOURTHYEIGHT,M,_). [1:1] //Minimizza celle TWOTHOUSANFOURTHYEIGHT
		
		#>
		if_no_answerset{
			System.out.println("No Answer Set");
			result.add("noAS");
		}	
		
		if(res.size()!=0){
			System.out.println("Mossa scelta "+res.get(0));
			
			if(move.getPrevious()!=null)
				System.out.println("PreviousChoice("+'"'+move.getPrevious().name()+'"'+").");
				
			return res.get(0);
		}
		
		return "ALTRO";
	}
		
	public void writeFactsFile(List<Fact> source,Move m)
	{
	  try
     {
          FileOutputStream fos = new FileOutputStream("./facts.txt");
          PrintStream write = new PrintStream(fos);
          for(Fact f:source)
          	{
            	    write.println(f+".");
          	}
          if(!strategy.equals("null"))
          {
          	write.println("CommonChoice("+'"'+strategy+'"'+").");
          }
          if(m.getPrevious()!=null)
          {
          	write.println("PreviousChoice("+'"'+m.getPrevious().name()+'"'+").");
          }
          
      }
         catch (IOException e)
      {
          System.out.println("Errore: " + e);
          System.exit(1);
      }
      
	}
	
	
	public Fact generateFactS(int values[][], int score, String m) 
	{
		int E, TWO, FOUR, EIGHT, SIXTEEN, THIRTYTWO, SIXTYFOUR,
			ONEHUNDREDTWENTYEIGHT, TWOHUNDREDFIFTYSIX, FIVEHUNDREDTWELVE,
			ONETHOUSANDTWENTYFOUR, TWOTHOUSANDFOURTHYEIGHT, V;
		String M;
		
		E = 0;
		TWO = 0;
		FOUR = 0;
		EIGHT = 0;
		SIXTEEN = 0;
		THIRTYTWO = 0;
		SIXTYFOUR = 0;
		ONEHUNDREDTWENTYEIGHT = 0;
		TWOHUNDREDFIFTYSIX = 0;
		FIVEHUNDREDTWELVE = 0;
		ONETHOUSANDTWENTYFOUR = 0;
		TWOTHOUSANDFOURTHYEIGHT = 0;
		V = score;
		M = m;
 
		for (int i = 0; i < 4; i++)
		{
			for (int j = 0; j < 4; j++) {
				/*if(values[i][j]== 0)
				{
					E++;
				}
				if(values[i][j]==2)
				{
					TWO++;
				}
				if(values[i][j]==4)
				{ 
					FOUR++;
				}
				if(values[i][j]==8)
				{ 
					EIGHT++;
				}else if(values[i][j]==16)
				{ 
					
				}else if(values[i][j]==32)
				{
					
				}else if(values[i][j]==64)
				{
					
				}else if(values[i][j]==128)
				{
					
				}else if(values[i][j]==256)
				{
					
				}else if(values[i][j]==512)
				{
					
				}else if(values[i][j]==1024)
				{
					
				}else if(values[i][j]==2048)
				{
					
				}
					
				*/switch (values[i][j]) {
				case 0: E++;
					break;
				case 2:
					TWO++;
					break;
				case 4:
					FOUR++;
					break;
				case 8:
					EIGHT++;
					break;
				case 16:
					SIXTEEN++;
					break;
				case 32:
					THIRTYTWO++;
					break;
				case 64:
					SIXTYFOUR++;
					break;
				case 128:
					ONEHUNDREDTWENTYEIGHT++;
					break;
				case 256:
					TWOHUNDREDFIFTYSIX++;
					break;
				case 512:
					FIVEHUNDREDTWELVE++;
					break;
				case 1024:
					ONETHOUSANDTWENTYFOUR++;
					break;
				case 2048:
					TWOTHOUSANDFOURTHYEIGHT++;
					break;
					
			}
		}
	}
	return new Fact(E, TWO, FOUR, EIGHT, SIXTEEN, THIRTYTWO,
		SIXTYFOUR, ONEHUNDREDTWENTYEIGHT, TWOHUNDREDFIFTYSIX,
		FIVEHUNDREDTWELVE, ONETHOUSANDTWENTYFOUR,
		TWOTHOUSANDFOURTHYEIGHT, V, M);
	
	
}	
}